package au.com.codeka.warworlds.server.ctrl;

import java.sql.ResultSet;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Random;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

import org.joda.time.DateTime;

import au.com.codeka.common.PointCloud;
import au.com.codeka.common.Vector2;
import au.com.codeka.common.protobuf.Messages;
import au.com.codeka.warworlds.server.RequestException;
import au.com.codeka.warworlds.server.data.DB;
import au.com.codeka.warworlds.server.data.SqlStmt;
import au.com.codeka.warworlds.server.model.Planet;
import au.com.codeka.warworlds.server.model.Sector;
import au.com.codeka.warworlds.server.model.Star;

/**
 * This class generates a new sector, populated with stars and whatnot.
 */
public class SectorGenerator {
    private Random mRandom;

    /**
     * This is used to choose a star type at a given point in the map.
     */
    static int[] StarTypeBonuses = {30, 40, 50, 40, 30, 0, 0};

    /**
     * Bonuses for generating the number of planets around a star (0 & 1 are basically impossible)
     */
    static int[] PlanetCountBonuses = {-9999, -9999, 0, 10, 20, 10, 5, 0};

    /**
     * Planet type bonuses. The bonuses for each entry need to be added to get the "final" bonus
     */
    static int[][] PlanetTypeSlotBonuses = {
      // #GasGiant #Radiated #Inferno #Asteroids #Water #Toxic #Desert #Swamp #Terran
        {-20,      10,       20,      -20,       -20,   0,     10,     0,     -10}, // close to sun
        {-10,      0,        10,      -20,       0,     0,     0,      0,     -10},
        {0,        -10,      -10,     0,         0,     0,     0,      0,     20},
        {10,       -10,      -20,     0,         10,    0,     -10,    10,    25},
        {20,       -20,      -30,     -10,       10,    0,     -20,    10,    30},
        {20,       -20,      -40,     -10,       0,     0,     -30,    0,     5},
        {30,       -20,      -40,     -10,       0,     0,     -30,    0,     0}    // far from sun
    };
    static int[][] PlanetTypeStarBonuses = {
        // #GasGiant #Radiated #Inferno #Asteroids #Water #Toxic #Desert #Swamp #Terran
        {-10,      0,        0,       -10,       10,    -10,   0,      10,    40},  // blue
        {-10,      -5,       -10,     -10,       20,    -10,   0,      20,    50},  // white
        {-10,      -5,       -20,     -10,       30,    -10,   0,      30,    60},  // yellow
        {-20,      -15,      -30,     -10,       30,    -5,    0,      40,    70},  // orange
        {-20,      -15,      -40,     -10,       20,    -5,    0,      40,    80},  // red
        {-30,      20,       10,      -10,       -10,   0,     -10,    -10,   -30}, // neutron
        {-30,      30,       20,      -10,       -20,   0,     -10,    -10,   -30}, // black hole
    };
    
    /**
     * Planet size is a normalized random number with the following bonus added. Each planet
     * type has a different size "distribution"
     */
    static int[] PlanetSizeBonuses = {
     // #GasGiant #Radiated #Inferno #Asteroids #Water #Toxic #Desert #Swamp #Terran
        30,       -10,      0,       0,         10,    -10,   0,      0,     0
    };

    // Planet population is calculated based on the size of the planet (usually, the bigger
    // the planet, the higher the potential population) but also the following bonuses are
    // applied.
    static double[] PlanetPopulationBonuses = {
     // #GasGiant #Radiated #Inferno #Asteroids #Water #Toxic #Desert #Swamp #Terran
        0.4,      0.4,      0.4,     0.0,       0.9,   0.6,   0.9,    0.6,   1.0
    };
    static double[] PlanetFarmingBonuses = {
     // #GasGiant #Radiated #Inferno #Asteroids #Water #Toxic #Desert #Swamp #Terran
        0.4,      0.2,      0.2,     0.0,       1.0,   0.4,   0.6,    0.8,   1.2
    };
    static double[] PlanetMiningBonuses = {
     // #GasGiant #Radiated #Inferno #Asteroids #Water #Toxic #Desert #Swamp #Terran
        0.8,      1.2,      1.0,     1.5,       0.8,   0.4,   0.6,    0.6,   0.8
    };

    public Sector generate(long x, long y) throws RequestException {
        mRandom = new Random((x * 73649274L) ^ y ^ System.currentTimeMillis());

        String sql = "INSERT INTO sectors (x, y, distance_to_centre, num_colonies) VALUES (?, ?, ?, ?)";
        try (SqlStmt stmt = DB.prepare(sql, Statement.RETURN_GENERATED_KEYS)) {
            Sector sector = new Sector(x, y);

            stmt.setLong(1, sector.getX());
            stmt.setLong(2, sector.getY());
            stmt.setDouble(3, sector.getDistanceToCentre());
            stmt.setInt(4, sector.getNumColonies());
            stmt.update();
            sector.setID(stmt.getAutoGeneratedID());

            // we just hard-code some values for density and randomness that look good...
            double density = 0.18;
            double randomness = 0.11;
            ArrayList<Vector2> points = new PointCloud.PoissonGenerator()
                                            .generate(density, randomness, mRandom);

            for (Vector2 point : points) {
                Star star = generateStar(sector, point);
                sector.getStars().add(star);
            }

            return sector;
        } catch (Exception e) {
            throw new RequestException(e);
        }
    }

    /**
     * Expands the universe by one sector.
     */
    public void expandUniverse() throws RequestException {
        TreeMap<Long, Set<Long>> existingSectors = new TreeMap<Long, Set<Long>>();
        long minX = 0, minY = 0, maxX = 0, maxY = 0;
        String sql = "SELECT x, y FROM sectors";
        try (SqlStmt stmt = DB.prepare(sql)) {
            ResultSet rs = stmt.select();
            while (rs.next()) {
                long x = rs.getLong(0);
                long y = rs.getLong(1);

                Set<Long> xs = existingSectors.get(y);
                if (xs == null) {
                    xs = new TreeSet<Long>();
                    existingSectors.put(y, xs);
                }
                xs.add(x);

                if (minX > x) {
                    minX = x;
                }
                if (minY > y) {
                    minY = y;
                }
                if (maxX < x) {
                    maxX = x;
                }
                if (maxY < y) {
                    maxY = y;
                }
            }
        } catch (Exception e) {
            throw new RequestException(e);
        }

        int numGenerated = 0;
        while (numGenerated < 50) {
            for (long x = minX; x <= maxX; x++) {
                for (long y = minY; y <= maxY; y++) {
                    Set<Long> xs = existingSectors.get(y);
                    if (xs == null || !xs.contains(x)) {
                        generate(x, y);
                        numGenerated ++;
                        if (numGenerated > 50) {
                            return;
                        }
                    }
                }
            }

            // if we get here, we ran out of coordinates
            minX --;
            maxX ++;
            minY --;
            maxY ++;
        }
    }

    private Star generateStar(Sector sector, Vector2 point) throws RequestException {
        int x = (int) ((Sector.SECTOR_SIZE - 64) * point.x) + 32;
        int y = (int) ((Sector.SECTOR_SIZE - 64) * point.y) + 32;
        int starTypeID = select(StarTypeBonuses);
        String name = new NameGenerator().generate(mRandom);
        int size = mRandom.nextInt(8) + 16;

        String sql = "INSERT INTO stars (sector_id, x, y, size, name, star_type, planets, last_simulation) VALUES (?, ?, ?, ?, ?, ?, ?, ?)";
        try (SqlStmt stmt = DB.prepare(sql, Statement.RETURN_GENERATED_KEYS)) {
            Star star = new Star(sector, x, y, starTypeID, name, size);

            ArrayList<Planet> planets = generatePlanets(star);
            // serialize the planets to a protobuf for storage
            Messages.Planets.Builder planets_pb = Messages.Planets.newBuilder();
            for (Planet planet : planets) {
                Messages.Planet.Builder planet_pb = Messages.Planet.newBuilder();
                planet.toProtocolBuffer(planet_pb);
                planets_pb.addPlanets(planet_pb);
            }

            Planet[] planetArray = new Planet[planets.size()];
            star.setPlanets(planets.toArray(planetArray));

            stmt.setInt(1, star.getSectorID());
            stmt.setInt(2, star.getOffsetX());
            stmt.setInt(3, star.getOffsetY());
            stmt.setInt(4, star.getSize());
            stmt.setString(5, name);
            stmt.setInt(6, star.getStarType().getType().ordinal());
            stmt.setBlob(7, planets_pb.build().toByteArray());
            stmt.setDateTime(8, DateTime.now());
            stmt.update();
            star.setID(stmt.getAutoGeneratedID());

            return star;
        } catch(Exception e) {
            throw new RequestException(e);
        }
    }

    private ArrayList<Planet> generatePlanets(Star star) {
        int numPlanets = 0;
        while (numPlanets < 2) {
            numPlanets = select(PlanetCountBonuses);
        }

        ArrayList<Planet> planets = new ArrayList<Planet>();
        for (int planetIndex = 0; planetIndex < numPlanets; planetIndex++) {
            int[] bonuses = new int[PlanetTypeSlotBonuses[0].length];
            for (int i = 0; i < bonuses.length; i++) {
                bonuses[i] = PlanetTypeSlotBonuses[planetIndex][i] +
                             PlanetTypeStarBonuses[star.getStarType().getType().ordinal()][i];
            }
            int planetType = select(bonuses);

            int size = normalRandom(100) + PlanetSizeBonuses[planetType];
            size = (int)(10 + (size / 2.5));

            double populationMultiplier = PlanetPopulationBonuses[planetType];
            populationMultiplier *= (size * 2.0) / 50.0;

            double farmingMultiplier = PlanetFarmingBonuses[planetType];
            double miningMultiplier = PlanetMiningBonuses[planetType];

            Planet planet = new Planet(star, planetIndex + 1,
                                       planetType, size,
                                       (int)(normalRandom(1000) * populationMultiplier),
                                       (int)(normalRandom(100) * farmingMultiplier),
                                       (int)(normalRandom(100) * miningMultiplier));
            planets.add(planet);
        }

        return planets;
    }

    /**
     * Selects an index from a list of bonuses.
     *
     * For example, if you pass in [0,0,0,0], then all four indices are equally likely and
     * we will return a value in the range [0,4) with equal probability. If you pass in something
     * like [0,0,30] then the third item has a "bonus" of 30 and is hence 2 is a far more likely
     * result than 0 or 1.
     */
    private int select(int[] bonuses) {
        int[] values = new int[bonuses.length];
        int total = 0;

        for (int i = 0; i < bonuses.length; i++) {
            int bonus = bonuses[i];
            int n = bonus + normalRandom(100);
            if (n > 0) {
                total += n;
                values[i] = n;
            } else {
                values[i] = 0;
            }
        }

        int randValue = mRandom.nextInt(total);
        for (int i = 0; i < values.length; i++) {
            randValue -= values[i];
            if (randValue <= 0) {
                return i;
            }
        }

        throw new RuntimeException("Should not get here!");
    }

    /**
     * Generates a random number that has an approximate normal distribution around the midpoint.

     * For example, if maxValue=100 then you'll most get values around 50 and only occasionally 0
     * or 100. Depending on the number of rounds, the tighter the distribution around the midpoint.
     */
    private int normalRandom(int max) {
        final int rounds = 3;

        int n = 0;
        int step = max / rounds;
        for (int i = 0; i < rounds; i++) {
            n += mRandom.nextInt(step - 1);
        }

        return n;
    }
}
